---
title: Slint 纯度
date: 2024-01-09 10:11:15
tags:
  - Slint
---
# Slint 纯度
**友情提示**
本章节内容本人做了一定的补充，实际内容和原文有一定区别。原文内容使用引用符号标注。

> Slint中的属性是评估是惰性的并且”相对的、被动“的。当某个属性在被读取时，才会评估属性绑定。属性之间的依赖关系是在属性评估过程中自动发现的。该属性存储评估的结果。当属性发生更改时，会通知所有依赖属性，以便下次读取其值时，重新评估其绑定。

这种加载方式和编程时用的懒拷贝技术并不是完全一样的，当存在一个主控件，此组件下面又存在多个小组件，他们的的宽度属性是这样设置的： `width : parent.width % 75%`。我们可以得知，子组件的宽度属性是父组件的75% 。
实际上实现的效果并不是在每一帧的渲染中将父组件的宽度属性乘上75%的值设置给子控件，而是在第一次设置之后，当上级组件发生属性改变之后，再将值传给后依赖此属性的后续组件。

> 为了让任何相对系统都能正常工作，评估一个属性不应该改变任何可观察的状态，而应该改变属性本身。如果是这样的话，那么这个表达是“纯的”，否则就被认为有副作用。副作用是有问题的，因为并不总是清楚它们何时会发生：懒惰的评估可能会改变它们的顺序，或者影响它们是否会发生。此外，在属性的绑定评估过程中，由于副作用而对属性进行的更改可能会导致意外行为。

如果我们写出类似这样的代码：
```Slint
component A {
	Rectangle{
		@children
	}
}

component MainWindow inherits Window{
	width: A.width
	A{
		width: parent.width
	}
}
```
实际上这样的代码是无法运行的，仅借此表示一个直观的含义。主窗口的宽度需要组件A的宽度，然而组件A依赖MainWindow的宽度，一旦有一个组件被i修改了，这样就很难评估改变的顺序，这也会导致产生以外的行为。

> 因此，Slint 中的绑定必须是纯的。 Slint 编译器强制纯上下文中的代码没有副作用。纯上下文包括绑定表达式、纯函数体和纯回调处理程序体。在这种情况下，不允许更改属性或调用非纯回调或函数。  
> 使用 pure 关键字注释回调和公共函数，以便可以从属性绑定和其他纯回调和函数访问它们。  
> 私有函数的纯度是自动推断的。您可以显式声明私有函数为“pure”，以使编译器强制执行其纯度。

```Slint
export component Example {
    pure callback foo() -> int;
    public pure function bar(x: int) -> int
    { return x + foo(); }
}
```